# Steganography
This app will hide data in images based on a shared key and a predetermined encryption complexity between a sender and a receiver.

Notice: This is pretty much just a project I created to learn Haskell, and while the crypto is probably strong the steganography is not!

## Maintaining security
To maintain security with this application, the following needs to be true.
* The picutre you are using **must** used for the sole purpose of hiding data once, or it would be obvious for someone looking at the picture that it contains hidden data.
  * The original **must not** be published anywhere (and will be automatically destroyed by the Steganography program during the encryption).
  * A picture **must not** be used more than once for encryption
* The picture **must not** be predictable.
  * The picture **should not** have filters applied.
    * The picture **must not** be greyscale.
  * The picture **must not** be generated by a computer.
* Different salts **should** be used every time.
* You **should** use relatively small keys for RSA (2048 bits ideally). See title RSA for details.
* **Don't trust me!** You **should** encrypt your data in another program before hiding it in an image. I am just a random person on the internet, and while I may have good intentions you have no way of proving that.
  * You **must not** use the same password for encrypting the data in this program as you did in the other program.

### A secure shared secret
The shared secret **should** be a file that ONLY you and the receiver has access to. If it's truely random it should be at least 32 bytes, but you could also use a significantly bigger secret, such as a picture.

### Recommended complexity
A minimum of 1000 iterations were recommended back in 2000 for PBKDF2. This number is greatly outdated, but I included it to give you a slight understanding of which sizes we're talking about. A rule of thumb is that it shold take you a long time to encrypt the data for it to be secure. Using a bigger shared secret allows you to use a smaller number for complexity.

### A secure salt
If you and the person/people you are sending data to has the same key then you mustn't use the same salt twice or you will have lowered the security of the data. To achieve this, a salt can be as simple as a unique identifier for you and a number which you raise for every package you send. For example:

> Alice sends a picture to Bob. They use the same secret. Alice uses the salt `Alice-1`. Bob receives the message, and knows who it's from and knows it's the first message and therefore applies the same salt when decrypting. Bob answers the message with the salt `Bob-1`, since it's his first message. The fact that they both used the number 1 is not an issue, since the salt still differs between the packages Alice and Bob sends. They can therefore have counters that tick independently of eachother.

The salt is not considered part of the secret, so including it with the picture would be ok. For example:

> Alice sends a picture to Bob in a mail. Besides the mail is the text "Check out this picture of my cute little Eve. She turned 3 today.". She uses the salt `Check out this picture of my cute little Eve. She turned 3 today.` for the encryption. A list **should** be kept of all salts used to make sure that the same salt isn't used twice.

## What the program does for you
If you do use the same password and salt every time, but change the picture, the program will still be extremely unlikely to create the same key stream for the secret data because a huge additional salt is read out from the picture before any sensitive data is added. It will, however, read out the salt (which consists of 1/30 of the picture chosen based on the secret) from the same positions in every picture you use (if the picture is of the same size), so there is still a tiny loss in security by not changing the salt.

## Technical description

### Pixel stream
A pixel stream is used to perform the Steganography encryption. It has the type `[(x, y, color, invertBit)]`. It refers to which pixel should be modified, where the data modified is the least significant bit of the pixel and color chosen. The bit that is read/written is inverted if invertBit is 1.

The pixel stream is generated by selecting a random element among a complete list of all valid values for `(x, y, color)` (with invertBit attached afterwards, disregarded for now). This is done by selecting a value in the range `[0..(len unusedPixels) - 1]` in the forementioned list. The value is chosen by extracting a big enough random number from the random stream. If the random number is too big, for example if you try to get a value between 0 and 12 (which would require 4 bits of random data) and you get the value 14, all four bits extracted from the random stream will be discarded and the random operation is retried.

A huge amount of data will be calculated (with parts of it discarded as described above) just to find the salt in the image, and after that a huge key is selected for PBKDF2, before any data is even touched. All of this needs to be calculated to find where in the pixel stream the user data even starts, and even more so to be able to find the user data encryption stream.

### Encryption/Decryption
Your password and salt will be used with the PBKDF2 function, with the number of iterations you have chosen. This will create the initial crypto stream `SHA512PBKDF2 { password = content(SHARED-SECRET-FILE), salt = salt, iter = complexity }`. The initial crypto stream will be used to fetch 1/30 of all pixels, and save their entire value in the chosen color in the variable `bigSalt`. Every seperate byte in `bigSalt` has a 50% chance of getting inverted before being used in the salt. The crypto stream will then be used to create the PBKDF2 random, `newPbkdfSecret`, and the first half of the AES256 key, `aesSecret1`. The crypto stream will now be replaced by the stream `hmacSha512Pbkdf2(newPbkdfSecret, bigSalt || yourSalt, 5 iterations)`. From this new crypto stream we read the second half of the AES256 key, `aesSecret2`. We now add the AES256 key to the stream by setting the stream to `drop(16 bytes, hmacSha512Pbkdf2(newPbkdfSecret, bigSalt || yourSalt), 5 iterations) âŠ• AES256(aesSecret1 || aesSecret2)`. This will be the "random data" used to chose pixels and xor values for the SHA1 sum and data.

This is done to assure that all user data is encrypted against an unique crypto stream every time, even if the same key and salt is being used.

This can all be verified in the function `createRandomStates` in Steganography.hs.

#### RSA
After the Encryption/Decryption step, RSA can be used. This is done by adding a public key for encryption and private key for decryption. For encryption a big random secret `bigRandom` will be created from the system random source (so not pseudorandom coming from the program). This random will be encrypted using OEAP and write it to the image in the exact same way as data is usually written. Once it has been put in the image a new salt `salt` of 256 bytes is generated. At this point a new cryptostream, `hmacSha512Pbkdf2(bigRandom, salt, 5)`, is added to the entropy sources.

On the receiving end it works pretty much the same, except `bigRandom` is read from the image and decrypted using the private key, after which the salt is created and they are both added to the new cryptostream in the same way.

Note that when you encrypt using a 2048 bit RSA key, the result will be 2048 bits long. This means that a 2048 key will probably change additionally 1024 bits in the image (or in the worst case 2048 bits), which makes the Steganography manipulation easier to detect. For this reason, if you want to keep the detection rate down you should have small RSA keys (or skip the RSA function all together). It will, however, add an extra layer of security where you could exchange keys over an untrusted channel.

If the private RSA keys are kept safe then it would be safe to only use the RSA encryption and let the symmetric encryption be known. A specific use case for this would be used to share symmetric keys in a group, to allow for broadcast messages while using RSA encryption for specific receivers. Notice: The messages aren't signed, so a receiver would not be able to verify the source of the encrypted message unless they are signed before they are encrypted with this program.

#### Encryption
Using the pixel stream, write a 40 byte SHA1 hash sum of the data to be encrypted, and append the data. All data using the pixel stream is subject to the invertBit variable in the pixel stream, so both the SHA1 sum and the data is now encrypted.

#### Decryption
Using the pixel stream, read out a 40 byte SHA1 hash sum from the image. Read out data byte by byte until the hash sum matches.

#### Encrypted stream format
The encrypted data is scattered around the image, but for simplicitys sake (to be able to verify security without relying on the shuffeling on data), the format is as follows:

| Data | Encrypted by symmetric key | Required | Comment |
| --- | :---: | :---: | --- |
| RSA OAEP Encrypted Key | x | | A symmetric key encrypted with a public RSA key. |
| Header | x | x | A single SHA1 hash sum of the form `SHA1(random(0..255)^256 || Enc(random, UserData))` |
| Data  | x | x | `User data` |

Worth noticing is that the SHA1 hash sum is done on a concatenation of a pseudo random 256 byte value and the user data encrypted with a seperate crypto key (fetched from the same pseudo random stream). This encryption of the user data is only used in this SHA1 sum and is then thrown away.

As you see in the previous table, the header for symmetric encryption is 160 bits long and leaks no information about the user data.

The header for public key encryption will be the key size of the RSA key + 160 bits and leaks no information about the user data, since the RSA encrypted symetric key adds to the encryption instead of replacing the encryption for the header and the data.

As shown in the table, everything is encrypted with the symmetric key and there is no known data in the protocol (such as length fields or a boolean informing if there is a RSA encrypted key or not) which an attacker could try to use to gain more knowledge.

### Known weaknesses
PBKDF2 is sensitive to SIMD brute force attacks, so in the future I will move away from it as my default PRNG.

**Using public key cryptography introduces brute force weakness**. Since OAEP has a checksum of sorts anyone with the private RSA key (which should not be the attacker) can brute force the symmetric key without having to verify the header against the data for every single attempt. Since the heaviest workload should be done before the RSA key is added into the mix (by having a strong key or a large number of iterations) this shouldn't be a problem in reality.

**The PNG images are sensitive to steganalysis**. I plan on reading up on which kinds of statistics are used for this kind of analysis and try to figure out if it's something I can compensate for.

## Future thoughts
I will add additional PRNG's. The one that comes to mind now is scrypt.

As this project is still in early development, I do not guarantee backwards or forwards compatibility between versions of this program.

## Disclaimer
As stated before, **do not trust me!** I will not take responsibility if this crypto is broken alongside with all of your bones as a result from it. Using this program is your choice and what you do with it or what happens because of it is your responsibility. This is delivered as is.

**I do not recommend anyone using this program for truely sensitive information**. There are weaknesses, especially against steganalysis, which allows an attacker to know that there actually is hidden data in the image.

**If you do find a vulnerable aspect of this program that I haven't considered, please contact me!**
