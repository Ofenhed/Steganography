# Steganography
This app will hide data in images based on a shared key and a predetermined encryption complexity between a sender and a receiver.

## Maintaining security
To maintain security with this application, the following needs to be true.
* The picutre you are using **must** used for the sole purpose of hiding data once, or it would be obvious for someone looking at the picture that it contains hidden data.
  * The original **must not** be published anywhere (and will be automatically destroyed by the Steganography program during the encryption).
  * A picture **must not** be used more than once for encryption
* The picture **must not** be predictable.
  * The picture **should not** have filters applied.
    * The picture **must not** be greyscale.
  * The picture **must not** be generated by a computer.
* Different salts **should** be used every time.
* **Don't trust me!** You **should** encrypt your data in another program before hiding it in an image. I am just a random person on the internet, and while I may have good intentions you have no way of proving that.
  * You **must not** use the same password for encrypting the data in this program as you did in the other program.

### A secure shared secret
The shared secret **should** be a file that ONLY you and the receiver has access to. If it's truely random it should be at least 32 bytes, but you could also use a significantly bigger secret, such as a picture.

### Recommended complexity
A minimum of 1000 iterations were recommended back in 2000 for PBKDF2. This number is greatly outdated, but I included it to give you a slight understanding of which sizes we're talking about. A rule of thumb is that it shold take you a long time to encrypt the data for it to be secure. Using a bigger shared secret allows you to use a smaller number for complexity.

### A secure salt
If you and the person/people you are sending data to has the same key then you mustn't use the same salt twice or you will have lowered the security of the data. To achieve this, a salt can be as simple as a unique identifier for you and a number which you raise for every package you send. For example:

> Alice sends a picture to Bob. They use the same secret. Alice uses the salt `Alice-1`. Bob receives the message, and knows who it's from and knows it's the first message and therefore applies the same salt when decrypting. Bob answers the message with the salt `Bob-1`, since it's his first message. The fact that they both used the number 1 is not an issue, since the salt still differs between the packages Alice and Bob sends. They can therefore have counters that tick independently of eachother.

The salt is not considered part of the secret, so including it with the picture would be ok. For example:

> Alice sends a picture to Bob in a mail. Besides the mail is the text "Check out this picture of my cute little Eve. She turned 3 today.". She uses the salt `Check out this picture of my cute little Eve. She turned 3 today.` for the encryption. A list **should** be kept of all salts used to make sure that the same salt isn't used twice.

## What the program does for you
If you do use the same password and salt every time, but change the picture, it will still not create the same key stream for the secret data because a salt is read out from the picture before any sensitive data is added. It will, however, read out the salt (32 bytes) from the same positions in every picture you use, so there is still a loss in security by not changing the salt.

## Technical description

### Pixel stream
A pixel stream is used to perform the Steganography encryption. It has the type `[(x, y, color, invertBit)]`. It refers to which pixel should be modified, where the data modified is the least significant bit of the pixel and color chosen. The bit that is read/written is inverted if invertBit is 1.

The pixel stream is generated by selecting a random element among a complete list of all valid values for `(x, y, color)` (with invertBit attached afterwards, disregarded for now). This is done by selecting a value in the range `[0..(len unusedPixels) - 1]` in the forementioned list. The value is chosen by extracting a big enough random number from the random stream. If the random number is too big, for example if you try to get a value between 0 and 12 (which would require 4 bits of random data) and you get the value 14, all four bits extracted from the random stream will be discarded and the random operation is retried. This means that to be able to read byte(x) you must know random(x), and to know random(x) you must know random(x-1), since you will not be able to know how much random data has been discarded otherwise.

For a picture of size `x * y`, at least `bitsUsed(x*y*3) + bitsUsed(x*y*3-1) + ... + bitsUsed(x*y*3-255)` bits of random data will be used just for finding the image salt, where `bitsUsed(max)=1+floor(log2(max))`. This means that for a picture of 640 * 480 pixels, at least 5120 bits will be consumed while finding the image salt. Using SHA512PBKDF2 this will consume at least 10 blocks, which all has to be calculated to know exactly how many bits has actually been consumed.

### Encryption/decryption
The first thing the program does is to create the PRNG stream `SH512PBKDF2 { password = content(SHARED-SECRET-FILE), salt = salt, iter = complexity }`, where `SHARED-SECRET-FILE`, `complexity` and `salt` are command line options. This stream will be used generate a pixel stream of 32 bytes (256 pixels). That pixel stream will be used to read out a value from the image, `image-salt`. This is used to create a new PRNG stream, `SHA512PBKDF2 { password = content(SHARED-SECRET-FILE), salt = concat(salt, image-salt), iter = complexity }`. This stream is used to create a new pixel stream, which is the pixel stream which will be used after this part. The initial pixel stream has been discarded. After this part, encryption and decryption differs slightly.

#### Encryption
Using the pixel stream, write a 32 bit size value of the data to be encrypted, and append the data. All data using the pixel stream is subject to the invertBit variable in the pixel stream, so both the 32 bit value and the data is now encrypted.

#### Decryption
Using the pixel stream, read out a 32 bit size value from the image. Read out data according to the read size value.

### Known weaknesses
Brute force attacking up to the size value in the PNG file let's an attacker do sanity checking and discard files with a data length that is bigger than available pixels in the image. This is however, not likely to be a viable attack. In a future version I consider adding the much slower approach of adding a SHA1 value of the data instead of a size value, where the decrypter checks for every byte read if the accumulated data matches the SHA1 value. If so, it will be an optional flag.

PBKDF2 is sensitive to SIMD brute force attacks, so in the future I will move away from it as my default PRNG.

## Future thoughts
I will add additional PRNG's. The ones that comes to mind now is AES256 and scrypt. The plan is to let multiple PRNG's generate bitstreams and xor them all together into a single PRNG stream.

As this project is still in early development, I do not guarantee backwards or forwards compatibility between versions of this program.

## Disclaimer
As stated before, **do not trust me!** I will not take responsibility if this crypto is broken alongside with all of your bones as a result from it. Using this program is your choice and what you do with it or what happens because of it is your responsibility. This is delivered as is.

**If you do find a vulnerable aspect of this program that I haven't considered, please contact me!**
