# Steganography
This app will hide data in images based on a shared key and a predetermined encryption complexity between a sender and a receiver.

## Maintaining security
To maintain security with this application, the following needs to be true.
* The picutre you are using **must** used for the sole purpose of hiding data once, or it would be obvious for someone looking at the picture that it contains hidden data.
  * The original **must not** be published anywhere (and will be automatically destroyed by the Steganography program during the encryption).
  * A picture **must not** be used more than once for encryption
* The picture **must not** be predictable.
  * The picture **should not** have filters applied.
    * The picture **must not** be greyscale.
  * The picture **must not** be generated by a computer.
* Different salts **should** be used every time.
* **Don't trust me!** You **should** encrypt your data in another program before hiding it in an image. I am just a random person on the internet, and while I may have good intentions you have no way of proving that.
  * You **must not** use the same password for encrypting the data in this program as you did in the other program.

### A secure salt
If you and the person/people you are sending data to has the same key then you mustn't use the same salt twice or you will have lowered the security of the data. To achieve this, a salt can be as simple as a unique identifier for you and a number which you raise for every package you send. For example:

> Alice sends a picture to Bob. They use the same secret. Alice uses the salt `Alice-1`. Bob receives the message, and knows who it's from and knows it's the first message and therefore applies the same salt when decrypting. Bob answers the message with the salt `Bob-1`, since it's his first message. The fact that they both used the number 1 is not an issue, since the salt still differs between the packages Alice and Bob sends. They can therefore have counters that tick independently of eachother.

The salt is not considered part of the secret, so including it with the picture would be ok. For example:

> Alice sends a picture to Bob in a mail. Besides the mail is the text "Check out this picture of my cute little Eve. She turned 3 today.". She uses the salt `Check out this picture of my cute little Eve. She turned 3 today.` for the encryption. A list **should** be kept of all salts used to make sure that the same salt isn't used twice.

## What the program does for you
If you do use the same password and salt every time, but change the picture, it will still not create the same key stream for the secret data because a salt is read out from the picture before any sensitive data is added. It will, however, read out the salt (32 bytes) from the same positions in every picture you use, so there is still a loss in security by not changing the salt.

## Technical description
### Pixel stream
A pixel stream is used to perform the Steganography encryption. It has the type `[(x, y, color, invertBit)]`. It refers to which pixel should be modified, where the data modified is the least significant bit of the pixel and color chosen. The bit that is read/written is inverted if invertBit is 1.

### Encryption/decryption
The first thing the program does is to create the PRNG stream `PBKDF2 { password = content(SHARED-SECRET-FILE), salt = salt }`, where `SHARED-SECRET-FILE` and `salt` are command line options. This stream will be used generate a pixel stream of 32 bytes (256 pixels). That pixel stream will be used to read out a value from the image, `image-salt`. This is used to create a new PRNG stream, `PBKDF2 { password = content(SHARED-SECRET-FILE), salt = concat(salt, image-salt) }`. This stream is used to create a new pixel stream, which is the pixel stream which will be used after this part. The initial pixel stream has been discarded. After this part, encryption and decryption differs slightly.

#### Encryption
Using the pixel stream, write a 32 bit size value of the data to be encrypted, and append the data. All data using the pixel stream is subject to the invertBit variable in the pixel stream, so both the 32 bit value and the data is now encrypted.

#### Decryption
Using the pixel stream, read out a 32 bit size value from the image. Read out data according to the read size value.

### Known weaknesses
Brute force attacking up to the size value in the PNG file let's an attacker do sanity checking and discard files with a data length that is bigger than available pixels in the image. This is however, not likely to be a viable attack. In a future version I consider adding the much slower approach of adding a SHA1 value of the data instead of a size value, where the decrypter checks for every byte read if the accumulated data matches the SHA1 value. If so, it will be an optional flag.
