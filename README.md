# Steganography
This app will hide data in images based on a shared key and a predetermined encryption complexity between a sender and a receiver.

Notice: This is pretty much just a project I created to learn Haskell, and while the crypto is probably strong the steganography is not!

## Maintaining security
To maintain security with this application, the following needs to be true.
* The picutre you are using **must** used for the sole purpose of hiding data once, or it would be obvious for someone looking at the picture that it contains hidden data.
  * The original **must not** be published anywhere (and will be automatically destroyed by the Steganography program during the encryption).
  * A picture **must not** be used more than once for encryption
* The picture **must not** be predictable.
  * The picture **should not** have filters applied.
    * The picture **must not** be greyscale.
  * The picture **must not** be generated by a computer.
* Different salts **should** be used every time.
* **Don't trust me!** You **should** encrypt your data in another program before hiding it in an image. I am just a random person on the internet, and while I may have good intentions you have no way of proving that.
  * You **must not** use the same password for encrypting the data in this program as you did in the other program.

### A secure shared secret
The shared secret **should** be a file that ONLY you and the receiver has access to. If it's truely random it should be at least 32 bytes, but you could also use a significantly bigger secret, such as a picture.

### Recommended complexity
A minimum of 1000 iterations were recommended back in 2000 for PBKDF2. This number is greatly outdated, but I included it to give you a slight understanding of which sizes we're talking about. A rule of thumb is that it shold take you a long time to encrypt the data for it to be secure. Using a bigger shared secret allows you to use a smaller number for complexity.

### A secure salt
If you and the person/people you are sending data to has the same key then you mustn't use the same salt twice or you will have lowered the security of the data. To achieve this, a salt can be as simple as a unique identifier for you and a number which you raise for every package you send. For example:

> Alice sends a picture to Bob. They use the same secret. Alice uses the salt `Alice-1`. Bob receives the message, and knows who it's from and knows it's the first message and therefore applies the same salt when decrypting. Bob answers the message with the salt `Bob-1`, since it's his first message. The fact that they both used the number 1 is not an issue, since the salt still differs between the packages Alice and Bob sends. They can therefore have counters that tick independently of eachother.

The salt is not considered part of the secret, so including it with the picture would be ok. For example:

> Alice sends a picture to Bob in a mail. Besides the mail is the text "Check out this picture of my cute little Eve. She turned 3 today.". She uses the salt `Check out this picture of my cute little Eve. She turned 3 today.` for the encryption. A list **should** be kept of all salts used to make sure that the same salt isn't used twice.

## What the program does for you
If you do use the same password and salt every time, but change the picture, the program will still be extremely unlikely to create the same key stream for the secret data because a huge additional salt is read out from the picture before any sensitive data is added. It will, however, read out the salt (which consists of 1/30 of the picture chosen based on the secret) from the same positions in every picture you use (if the picture is of the same size), so there is still a tiny loss in security by not changing the salt.

## Technical description

### Pixel stream
A pixel stream is used to perform the Steganography encryption. It has the type `[(x, y, color, invertBit)]`. It refers to which pixel should be modified, where the data modified is the least significant bit of the pixel and color chosen. The bit that is read/written is inverted if invertBit is 1.

The pixel stream is generated by selecting a random element among a complete list of all valid values for `(x, y, color)` (with invertBit attached afterwards, disregarded for now). This is done by selecting a value in the range `[0..(len unusedPixels) - 1]` in the forementioned list. The value is chosen by extracting a big enough random number from the random stream. If the random number is too big, for example if you try to get a value between 0 and 12 (which would require 4 bits of random data) and you get the value 14, all four bits extracted from the random stream will be discarded and the random operation is retried.

A huge amount of data will be calculated (with parts of it discarded as described above) just to find the salt in the image, and after that a huge key is selected for PBKDF2, before any data is even touched. All of this needs to be calculated to find where in the pixel stream the user data even starts, and even more so to be able to find the user data encryption stream.

### Encryption/Decryption
Your password and salt will be used with the PBKDF2 function, with the number of iterations you have chosen. This will create the initial crypto stream `SH512PBKDF2 { password = content(SHARED-SECRET-FILE), salt = salt, iter = complexity }`. The initial crypto stream will be used to fetch 1/30 of all pixels, and save their entire value in the chosen color in the variable `bigSalt`. Every seperate byte in `bigSalt` has a 50% chance of getting inverted before being used in the salt. The crypto stream will then be used to create the PBKDF2 random, `newPbkdfSecret`, and the first half of the AES256 key, `aesSecret1`. The crypto stream will now be replaced by the stream `hmacSha512Pbkdf2(newPbkdfSecret, bigSalt || yourSalt, 5 iterations)`. From this new crypto stream we read the second half of the AES256 key, `aesSecret2`. We now add the AES256 key to the stream by setting the stream to `drop(16 bytes, hmacSha512Pbkdf2(newPbkdfSecret, bigSalt || yourSalt), 5 iterations) âŠ• AES256(aesSecret1 || aesSecret2)`. This will be the "random data" used to chose pixels and xor values for the SHA1 sum and data.

This is done to assure that all user data is encrypted against an unique crypto stream every time, even if the same key and salt is being used.

This can all be verified in the function `createRandomStates` in Steganography.hs.

#### Encryption
Using the pixel stream, write a 40 byte SHA1 hash sum of the data to be encrypted, and append the data. All data using the pixel stream is subject to the invertBit variable in the pixel stream, so both the SHA1 sum and the data is now encrypted.

#### Decryption
Using the pixel stream, read out a 40 byte SHA1 hash sum from the image. Read out data byte by byte until the hash sum matches.

### Known weaknesses
PBKDF2 is sensitive to SIMD brute force attacks, so in the future I will move away from it as my default PRNG.

**The PNG images are sensitive to steganalysis**. I plan on reading up on which kinds of statistics are used for this kind of analysis and try to figure out if it's something I can compensate for.

## Future thoughts
I will add additional PRNG's. The ones that comes to mind now is AES256 and scrypt. The plan is to let multiple PRNG's generate bitstreams and xor them all together into a single PRNG stream.

As this project is still in early development, I do not guarantee backwards or forwards compatibility between versions of this program.

## Disclaimer
As stated before, **do not trust me!** I will not take responsibility if this crypto is broken alongside with all of your bones as a result from it. Using this program is your choice and what you do with it or what happens because of it is your responsibility. This is delivered as is.

**I do not recommend anyone using this program for truely sensitive information**. There are weaknesses, especially against steganalysis, which allows an attacker to know that there actually is hidden data in the image.

**If you do find a vulnerable aspect of this program that I haven't considered, please contact me!**
